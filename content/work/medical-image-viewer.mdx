---
title: "Cornerstone3D Medical Image Viewer"
slug: "medical-image-viewer"
description: "High-performance DICOM visualization with GPU-accelerated volume rendering, 3D segmentation, and comprehensive annotation tooling."
date: "2022-11-01"
featured: true
tags:
  - Medical Imaging
  - WebGL
  - DICOM
  - 3D Visualization
thumbnail: "/images/work/medical-viewer-thumb.jpg"
hero: "/images/work/medical-viewer-hero.jpg"
role: "Software Engineer"
timeline: "4 months"
team: "2 engineers"
tools:
  - TypeScript
  - Cornerstone3D
  - VTK.js
  - WebGL
  - WebAssembly
  - Web Workers
  - comlink
  - PolySeg
---

## Situation

The existing medical image viewer used a legacy per-slice rendering approach (ImageStack) that couldn't support modern clinical workflows. Radiologists needed volume-based rendering for advanced visualization, along with extensive annotation and editing tools for diagnostic work.

Key limitations of the legacy system:

- **Per-slice architecture**: ImageStack rendered individual slices without volumetric context
- **Limited 3D capabilities**: No real-time 3D segmentation or surface rendering
- **Performance issues**: UI blocking during heavy operations like paint and DICOM parsing
- **Format restrictions**: Incomplete support for NIfTI and other research formats

## Technical Architecture

### Volume Rendering Pipeline

Migrated the entire rendering system from ImageStack to Cornerstone3D's StreamingImageVolume:

```
┌─────────────────────────────────────────────────────┐
│                  Rendering Pipeline                  │
├─────────────────────────────────────────────────────┤
│  DICOM Files → Cornerstone3D Volume → WebGL Canvas  │
│       ↓              ↓                    ↓         │
│   Parsing      GPU Textures          60fps Render   │
└─────────────────────────────────────────────────────┘
```

- WebGL-based GPU rendering for smooth 60fps performance
- Real-time window/level adjustments with immediate visual feedback
- Progressive loading with priority queuing for visible slices
- Texture atlas management for efficient GPU memory usage

### Web Worker Architecture

Implemented off-main-thread processing using the comlink library:

```
┌─────────────────────────────────────────────────────┐
│              Web Worker Architecture                 │
├─────────────────────────────────────────────────────┤
│  Main Thread ←─ comlink ─→ Web Worker               │
│       ↓                         ↓                   │
│  UI Updates               Heavy Computation         │
│  (60fps)                 (DICOM parsing, paint)     │
└─────────────────────────────────────────────────────┘
```

- Typed Promise-based API via comlink for clean worker communication
- Batch processing of paint operations at 60fps to prevent UI jank
- Off-main-thread DICOM parsing for large datasets
- SharedArrayBuffer for zero-copy data transfer where supported

### 3D Segmentation with PolySeg

Built real-time 3D surface generation from 2D labelmap data:

```
┌─────────────────────────────────────────────────────┐
│           3D Segmentation with PolySeg              │
├─────────────────────────────────────────────────────┤
│  Labelmap → WASM Marching Cubes → VTK.js Mesh       │
│     ↓              ↓                   ↓            │
│  2D Slice     3D Surface           GPU Render       │
│  Editing      Generation           Display          │
└─────────────────────────────────────────────────────┘
```

- WebAssembly-based marching cubes algorithm for performance
- Real-time labelmap to 3D mesh conversion as users edit
- VTK.js actors for surface rendering with proper lighting
- Direct actor management to avoid flicker during updates

### Coordinate System Handling

Implemented robust coordinate transformations for medical imaging:

- DICOM Patient Coordinate System (physical mm) as the canonical reference
- `canvasToWorld()` → `worldToIndex()` transformation pipeline
- NIfTI support with proper RAS→LPS conversion for neuroimaging data
- Consistent coordinate handling across all tools and viewports

### Editing Tools

Built 16+ specialized editing tools for clinical workflows:

- **Drawing**: Paint brush, eraser, polygon fill
- **Selection**: Rectangle, ellipse, freehand regions
- **Segmentation**: Region growing, threshold-based selection
- **Measurement**: Lines, angles, point markers
- **Editing**: Bounding boxes, contour adjustment
- **3D**: Volume sculpting, surface cleanup

## Key Technical Achievement

During NIfTI format integration, I discovered and fixed a critical spacing calculation bug in the loader. The original implementation extracted spacing values directly from the affine matrix diagonal, which is incorrect when the affine contains rotation.

**Incorrect approach:**
```typescript
spacing = [affine[0][0], affine[1][1], affine[2][2]]
```

**Correct calculation:**
```typescript
spacing = [
  Math.sqrt(affine[0][0]² + affine[1][0]² + affine[2][0]²),
  Math.sqrt(affine[0][1]² + affine[1][1]² + affine[2][1]²),
  Math.sqrt(affine[0][2]² + affine[1][2]² + affine[2][2]²)
]
```

This fix ensured proper voxel spacing regardless of image orientation, which is critical for accurate measurements and coordinate transformations.

## Learnings

### What Worked Well

- **Cornerstone3D ecosystem**: The library's architecture made complex rendering achievable
- **comlink abstraction**: Clean worker communication without manual message handling
- **Incremental migration**: Moving one feature at a time reduced risk

### What I'd Do Differently

- **Earlier PolySeg integration**: Waited too long to implement 3D segmentation
- **Better TypeScript types**: Some Cornerstone3D internals needed custom type definitions

### Technical Insights

- GPU texture upload is often the bottleneck, not rendering itself
- WebAssembly provides significant speedups for computational geometry
- Medical imaging coordinate systems have many edge cases—test extensively

---

*This project demonstrated that web technologies can handle demanding medical imaging workloads when you leverage WebGL, WebAssembly, and Web Workers effectively.*
