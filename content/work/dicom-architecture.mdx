---
title: "DICOM Retrieval Architecture"
slug: "dicom-architecture"
description: "Migrated from slow C-FIND protocol to Orthanc REST API for faster, more flexible medical image queries."
date: "2022-05-15"
featured: false
tags:
  - Systems Architecture
  - Infrastructure
  - DICOM
  - REST API
thumbnail: "/images/work/dicom-arch-thumb.jpg"
role: "Backend Engineer"
timeline: "1 month"
team: "2 engineers"
tools:
  - TypeScript
  - Orthanc
  - REST API
  - SQLite
---

## Problem

The existing DICOM retrieval system relied on the native C-FIND protocol for querying patient studies and images. This approach had significant limitations:

```
┌─────────────────────────────────────────────────────┐
│            Before: C-FIND Protocol                  │
├─────────────────────────────────────────────────────┤
│  App → C-FIND → PACS (sequential, slow)             │
└─────────────────────────────────────────────────────┘
```

- **Sequential queries only**: C-FIND doesn't support batching or parallel requests
- **Limited filtering**: Query capabilities restricted by DICOM standard
- **Slow performance**: Each query required a full network round-trip to the PACS
- **No caching**: Every query hit the PACS directly

## Solution

Migrated to Orthanc DICOM server's REST API, which maintains an internal SQLite index of all DICOM data:

```
┌─────────────────────────────────────────────────────┐
│            After: REST API + Orthanc                │
├─────────────────────────────────────────────────────┤
│  App → REST API → Orthanc → SQLite Index            │
│       (parallel, batched, cached)                   │
└─────────────────────────────────────────────────────┘
```

### Technical Implementation

**Query Migration**

Replaced all C-FIND calls with equivalent REST API requests:

- `/patients` endpoint for patient-level queries
- `/studies` endpoint with filtering parameters
- `/series` and `/instances` for granular access
- Metadata available as JSON without parsing DICOM

**Parallel Request Handling**

Implemented batched parallel requests that weren't possible with C-FIND:

```typescript
// Before: Sequential C-FIND queries
for (const patientId of patientIds) {
  const result = await cfindQuery(patientId); // blocking
}

// After: Parallel REST API calls
const results = await Promise.all(
  patientIds.map(id => fetch(`/patients/${id}/studies`))
);
```

**Response Caching**

Added caching layer for repeated queries:

- In-memory cache for frequently accessed metadata
- Cache invalidation on DICOM store events
- Configurable TTL based on data volatility

### Orthanc Architecture

Orthanc provides several advantages over raw DICOM protocols:

- **SQLite index**: Pre-indexed metadata enables fast queries without scanning DICOM files
- **REST API**: Standard HTTP semantics with JSON responses
- **Plugin system**: Extensible for custom authentication and routing
- **DICOM gateway**: Still supports C-FIND/C-MOVE for legacy systems

## Results

The migration significantly improved query performance:

- **Faster response times**: REST API queries against SQLite index much faster than C-FIND to PACS
- **Batch operations**: Enabled bulk patient/study lookups that weren't possible before
- **Simpler code**: HTTP/JSON easier to work with than DICOM network protocol
- **Better observability**: Standard HTTP logging and monitoring

## Learnings

### What Worked Well

- **Orthanc reliability**: Mature project with good documentation
- **Incremental migration**: Ran C-FIND and REST API in parallel during transition
- **SQLite simplicity**: No need for separate database infrastructure

### What I'd Do Differently

- **Earlier evaluation**: Should have considered Orthanc from the start
- **Better cache strategy**: Initial cache TTLs needed tuning

### Technical Insights

- DICOM protocols have quirks; REST APIs are much more predictable
- SQLite performs well for read-heavy query workloads
- Orthanc's plugin architecture allows customization without forking

---

*This project reinforced the value of choosing the right abstraction layer—sometimes a well-designed middleware can solve problems that seem inherent to the underlying protocol.*
